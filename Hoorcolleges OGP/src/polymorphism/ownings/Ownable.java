package polymorphism.ownings;import java.math.BigInteger;import be.kuleuven.cs.som.annotate.*;import polymorphism.exceptions.*;import polymorphism.persons.Person;/** * A class of things with a value that can be owned by persons.  *  * @invar   Each ownable can have its value as its value. *        | canHaveAsValue(getValue()) * @invar   Each ownable must have a proper owner. *        | hasProperOwner() *  * @version  2.0 * @author   Eric Steegmans */public abstract class Ownable {	/**	 * Check whether this ownable is terminated.	 */	@Basic	public boolean isTerminated() {		// We do not want to introduce an extra instance variable		// reflecting whether or not an ownable is terminated.		// Instead, we use a value for the instance variable		// 'value', that is illegal for non-terminated ownables.		return getValue() == null;	}	/**	 * Terminate this ownable.	 *	 * @effect  The owner, if any, is unset from this ownable.	 *        | unsetOwner()	 * @post    The value of this ownable may have changed.	 *        | new.canHaveAsValue(new.getValue())	 */	public void terminate() {		unsetOwner();		// At this point we cannot use the method setValue,		// because it does not accept null as a legal value.		this.value = null;	}	/**	 * Return the value of this ownable.	 * 	 * @note    For reasons of simplicity, the value of an ownable	 *          is expressed as a big integer. Obviously, it would	 *          be better to use a class of money amounts.	 */	@Basic	public BigInteger getValue() {		return this.value;	}	/**	 * Check whether this ownable can have the given value	 * as its value.	 * 	 * @param   value	 *          The value to be checked.	 * @return  True if this ownable is terminated, or if the	 *          given value is effective and not negative;	 *          false otherwise.	 *        | result ==	 *        |   (isTerminated() || 	 *        |   ( (value != null) &&	 *        |     (value.compareTo(BigInteger.ZERO) >= 0) ) )	 * @note    In the terminated state, any big integer is acceptable as	 *          the value of an ownable, including negative values and	 *          non-effective values. We do not want to expose that we	 *          use a null-reference for the value to represent the	 *          terminated state.	 */	@Raw	public boolean canHaveAsValue(BigInteger value) {		if (isTerminated())			return true;		return (value != null) && (value.compareTo(BigInteger.ZERO) >= 0);	}	/**	 * Set the value of this ownable to the given value.	 *	 * @param   value	 *          The new value for this ownable.	 * @post    The value of this ownable is the same as the given value.	 *        | new.getValue() == value	 * @throws  IllegalValueException	 *          This ownable cannot have the given value as its value.	 *        | ! canHaveAsValue(value))	 * @throws  IllegalStateException	 *          This ownable is terminated.	 *        | isTerminated()	 */	@Raw	public void setValue(BigInteger value) throws IllegalValueException,			IllegalStateException {		if (!canHaveAsValue(value))			throw new IllegalValueException(this, value);		if (isTerminated())			throw new IllegalStateException(					"No changes to terminated ownables!");		this.value = value;	}	/**	 * Variable referencing the value of this ownable.	 * 	 * @invar  If this ownable is terminated, its value is not effective.	 *         | if (isTerminated())	 *         |   then (value == null)	 * @note   We use a representation invariant to make clear that we	 *         expect the value of any terminated ownable to be 0.	 */	private BigInteger value = BigInteger.ZERO;	/**	 * Return the owner of this ownable.	 *   A null reference is returned if this ownable has no owner.	 */	@Basic	@Raw	public Person getOwner() {		return this.owner;	}		// Definition might need changes in view of restrictions that are	// specific for this association.	/**	 * Check whether this ownable can have the given owner	 * as its owner.	 *	 * @param   owner	 *          The owner to check.	 * @return  If this ownable is terminated, true if and only if	 *          the given owner is not effective.	 *        | if (this.isTerminated())	 *        |   then result == (owner == null)	 *          Otherwise, true if and only if the given owner is	 *          either not effective or not terminated.	 *        | else result ==	 *        |   (owner == null) || (! owner.isTerminated())	 */	@Raw	public boolean canHaveAsOwner(Person owner) {		if (this.isTerminated())			return (owner == null);		return (owner == null) || (!owner.isTerminated());	}	/**	 * Check whether this ownable has a proper owner.	 *	 * @return  True if and only if this ownable can have its owner as	 *          its owner, and if either the owner of this ownable is not	 *          effective or that owner has this ownable as one of its	 *          ownings.	 *        | result ==	 *        |   canHaveAsOwner(getOwner() &&	 *        |   ( (getOwner() == null) ||	 *        |     getOwner().hasAsOwning(this) )	 */	@Raw	public boolean hasProperOwner() {		return canHaveAsOwner(getOwner())				&& ((getOwner() == null) || getOwner()						.hasAsOwning(this));	}	/**	 * Check whether this ownable has an owner.	 *	 * @return  True if and only if the owner of this ownable is effective.	 *        | result == (getOwner() != null)	 */	@Raw	public boolean hasOwner() {		return getOwner() != null;	}	/**	 * Set the owner of this ownable to the given owner.	 *	 * @param   owner	 *          The new owner for this ownable.	 * @post    The owner of this ownable is the same as the given owner.	 *        | new.getOwner() == owner	 * @post    The number of ownings of the given owner	 *          is incremented by 1.	 *        | (new owner).getNbOwnings() == owner.getNbOwnings() + 1	 * @post    The given owner has this ownable as its new last	 *          owning.	 *        | (new owner).getOwningAt(getNbOwnings()+1) == this	 * @throws  IllegalArgumentException	 *          The given owner is not effective or it cannot have this ownable	 *          as its new last owning.	 *        | (owner == null) ||	 *        |   (! owner.canHaveAsOwningAt(this,owner.getNbOwnings()+1))	 * @throws  IllegalStateException	 *          This ownable already has a owner.	 *        | hasOwner()	 */	public void setOwnerTo(Person owner)			throws IllegalOwnerException, IllegalStateException {		if ((owner == null)				|| (!owner.canHaveAsOwningAt(this, owner						.getNbOwnings()+1)))			throw new IllegalOwnerException(owner,this);		if (this.hasOwner())			throw new IllegalStateException("Already has owner!");		setOwner(owner);		owner.addAsOwning(this);	}	/**	 * Unset the owner, if any, from this ownable.	 *	 * @post    This ownable no longer has an owner.	 *        | ! new.hasOwner()	 * @post    The former owner of this owning, if any, no longer	 *          has this owning as one of its ownings.	 *        |    (getOwner() == null)	 *        | || (! (new getOwner()).hasAsOwning(owning))	 * @post    All ownings registered beyond the position at which	 *          this owning was registered shift one position to the left.	 *        | (getOwner() == null) ||	 *        | (for each index in	 *        |        getOwner().getIndexOfOwning(owning)+1..getOwner().getNbOwnings():	 *        |    (new getOwner()).getOwningAt(index-1) == getOwner().getOwningAt(index) ) 	 */	public void unsetOwner() {		if (hasOwner()) {			Person formerOwner = this.getOwner();			setOwner(null);			formerOwner.removeAsOwning(this);		}	}	/**	 * Set the owner of this ownable to the given owner.	 *	 * @param   owner	 *          The new owner for this ownable.	 * @pre     This ownable can have the given owner as its owner.	 *        | canHaveAsOwner(owner)	 * @post    The owner of this ownable is the same as the given owner.	 *        | new.getOwner() == owner	 */	@Raw	private void setOwner(@Raw Person owner) {		assert canHaveAsOwner(owner);		this.owner = owner;	}	/**	 * Variable referencing the owner of this ownable.	 */	private Person owner;}