package polymorphism.persons;import java.math.BigInteger;import java.util.*;import java.lang.reflect.*;import polymorphism.ownings.*;import be.kuleuven.cs.som.annotate.*;/** * A class of persons involving a relation with things they own. *  * @invar   Each person must have proper ownings. *        | hasProperOwnings() *  * @version  2.0 * @author   Eric Steegmans */public class Person {	/**	 * Initialize this new person with no ownings.	 *	 * @post    This new person does not have any ownings yet.	 *        | new.getNbOwnings() == 0	 */	@Raw	public Person() {	}	/**	 * Check whether this person is terminated.	 */	@Basic	@Raw	public boolean isTerminated() {		return this.isTerminated;	}	/**	 * Terminate this person.	 *	 * @post    This person is terminated.	 *        | new.isTerminated()	 * @post    Each of the ownings of this person no longer has	 *          a owner.	 *        | for each owning in getAllOwnings():	 *        |	  (! (new owning).hasOwner())	 */	public void terminate() {		if (!isTerminated()) {			for (Ownable owning : getAllOwnings())				owning.unsetOwner();			this.isTerminated = true;		}	}	/**	 * Variable reflecting whether or not this person is terminated.	 */	private boolean isTerminated;	/**	 * Return the owning of this person at the given index.	 * 	 * @param   index	 *          The index of the owning to return.	 * @throws  IndexOutOfBoundsException	 *          The given index is not positive or it exceeds the	 *          number of ownings of this person.	 *        | (index < 1) || (index > getNbOwnings())	 */	@Basic	@Raw	public Ownable getOwningAt(int index) throws IndexOutOfBoundsException {		return ownings.get(index - 1);	}	/**	 * Return the number of ownings of this person.	 */	@Basic	@Raw	public int getNbOwnings() {		return ownings.size();	}	/**	 * Check whether this person can have the given owning	 * as one of its ownings.	 * 	 * @param   owning	 *          The owning to check.	 * @return  True if and only if the given owning is effective, and	 *          if that owning can have this person as its owner.	 *        | result ==	 *        |   (owning != null) &&	 *        |   owning.canHaveAsOwner(this)	 */	@Raw	public boolean canHaveAsOwning(Ownable owning) {		return (owning != null) && owning.canHaveAsOwner(this);	}	/**	 * Check whether this person can have the given owning	 * as one of its ownings at the given index.	 * 	 * @param   owning	 *          The owning to check.	 * @param   index	 *          The index to check.	 * @return  False if the given index is not positive or exceeds	 *          the number of ownings of this person + 1.	 *        | if ( (index < 1) || (index > getNbOwnings()+1) )	 *        |   then result == false	 *          Otherwise, false if this person cannot have the	 *          given owning as one of its ownings.	 *        | else if (! canHaveAsOwning(owning))	 *        |   then result == false	 *          Otherwise, true if and only if the given owning is	 *          not already registered at another index.	 *        | else result ==	 *        |   for each I in 1..getNbOwnings():	 *        |     ( (I == index) || (getOwningAt(I) != owning) )	 */	@Raw	public boolean canHaveAsOwningAt(Ownable owning, int index) {		if ((index < 1) || (index > getNbOwnings() + 1))			return false;		if (!canHaveAsOwning(owning))			return false;		for (int pos = 1; pos <= getNbOwnings(); pos++)			if ((pos != index) && (getOwningAt(pos) == owning))				return false;		return true;	}	/**	 * Check whether this person has a proper list of ownings.	 * 	 * @return  True if and only if this person can have each of its	 *          ownings at their index, and if each of these ownings	 *          references this person as their owner.	 *        | for each index in 1..getNbOwnings():	 *        |   canHaveAsOwningAt(getOwningAt(index),index) &&	 *        |   (getOwningAt(index).getOwner() == this)	 */	public boolean hasProperOwnings() {		for (int index = 1; index <= getNbOwnings(); index++) {			if (!canHaveAsOwningAt(getOwningAt(index), index))				return false;			if (getOwningAt(index).getOwner() != this)				return false;		}		return true;	}	/**	 * Check whether this person has the given owning as one of	 * its ownings.	 *	 * @param   owning	 *          The owning to check.	 * @return  True if and only if this person has the given owning	 *          as one of its ownings at some index.	 *        | result ==	 *        |   for some index in 1..getNbOwnings():	 *        |     getOwningAt(index).equals(owning)	 */	@Raw	public boolean hasAsOwning(Ownable owning) {		return ownings.contains(owning);	}	/**	 * Return the index at which the given owning is registered	 * in the list of ownings for this person.	 *  	 * @param  owning	 *         The owning to search for.	 * @return If this person has the given owning as one of its	 *         ownings, that owning is registered at the resulting	 *         index. Otherwise, the resulting value is -1.	 *       | if (hasAsOwning(owning))	 *       |    then getOwningAt(result) == owning	 *       |    else result == -1	 */	@Raw	public int getIndexOfOwning(Ownable owning) {		return ownings.indexOf(owning);	}	/**	 * Return a list of all the ownings of this person.	 * 	 * @return  The size of the resulting list is equal to the number of	 *          ownings of this person.	 *        | result.size() == getNbOwnings()	 * @return  Each element in the resulting list is the same as the	 *          owning of this person at the corresponding index.	 *        | for each index in 0..result-size()-1 :	 *        |   result.get(index) == getOwningAt(index+1)	 */	public List<Ownable> getAllOwnings() {		return new ArrayList<Ownable>(ownings);	}	/**	 * Add the given owning at the end of the list of	 * ownings of this person.	 * 	 * @param   owning	 *          The owning to be added.	 * @pre     The given owning is effective and already references	 *          this person as its owner.	 *        | (owning != null) && (owning.getOwner() == this)	 * @pre     This person does not not yet have the given owning	 *          as one of its ownings.	 *        | ! hasAsOwning(owning)	 * @post    The number of ownings of this person is incremented	 *          by 1.	 *        | new.getNbOwnings() == getNbOwnings() + 1	 * @post    This person has the given owning as its new last	 *          owning.	 *        | new.getOwningAt(getNbOwnings()+1) == owning	 */	public void addAsOwning(@Raw Ownable owning) {		assert (owning != null) && (owning.getOwner() == this);		assert !hasAsOwning(owning);		ownings.add(owning);	}	/**	 * Remove the given owning from the ownings of this person.	 * 	 * @param   owning	 *          The owning to be removed.	 * @pre     The given owning is effective and does not have any	 *          owner.	 *        | (owning != null) && (owning.getOwner() == null)	 * @pre     This person has the given owning as one of	 *          its ownings.	 *        | hasAsOwning(owning)	 * @post    The number of ownings of this person is decremented	 *          by 1.	 *        | new.getNbOwnings() == getNbOwnings() - 1	 * @post    This person no longer has the given owning as	 *          one of its ownings.	 *        | (! new.hasAsOwning(owning))	 * @post    All ownings registered beyond the removed owning	 *          shift one position to the left.	 *        | for each index in getIndexOfOwning(owning)+1..getNbOwnings():	 *        |   new.getOwningAt(index-1) == getOwningAt(index) 	 */	@Raw	public void removeAsOwning(Ownable owning) {		assert (owning != null) && (owning.getOwner() == null);		assert (hasAsOwning(owning));		ownings.remove(owning);	}	/**	 * Variable referencing a list collecting all the ownings of	 * this person.	 * 	 * @invar   The referenced list is effective.	 *        | ownings != null	 * @invar   Each owning registered in the referenced list is	 *          effective and not yet terminated.	 *        | for each owning in ownings:	 *        |   ( (owning != null) && (!owning.isTerminated()) )	 */	private final List<Ownable> ownings = new ArrayList<Ownable>();		public BigInteger getTotalValue(){		BigInteger totalSoFar = BigInteger.ZERO;		for (Ownable ownable:ownings){			totalSoFar = totalSoFar.add(ownable.getValue());		}		return totalSoFar;	}		public int getTotalFoodAmount(int nbDays){		//return getTotalFoodAmountPerDay()*nbDays;		try {			return getTotalFrom(Dog.class.getMethod("getDailyFoodAmount"))*nbDays;		} catch (NoSuchMethodException | SecurityException e) {			return -1;		}	}		public int getTotalFoodAmountPerDay(){		int totalSoFar = 0;		for (Ownable ownable:ownings){			if (ownable instanceof Dog)				totalSoFar += ((Dog) ownable).getDailyFoodAmount();		}		return totalSoFar;	}		public int getTotalFrom(Method method){		int totalSoFar = 0;		for (Ownable ownable:ownings){			//totalSoFar += ((Dog) ownable).getDailyFoodAmount();			try{				totalSoFar += (int) method.invoke(ownable);			} catch (Throwable e){			}		}		return totalSoFar;	} //Moeilijk leesbare code		public int getTotalFoodAmountPerDay2(){		int totalSoFar = 0;		for (Ownable ownable:ownings){			try{				totalSoFar += ((Dog) ownable).getDailyFoodAmount();			} catch (ClassCastException e){							}		}		return totalSoFar;	}	public int getTotalFoodAmountPerDay3(){		int totalSoFar = 0;		for (Ownable ownable:ownings){			if (Dog.class.isInstance(ownable))				totalSoFar += ((Dog) ownable).getDailyFoodAmount();		}		return totalSoFar;	}	}